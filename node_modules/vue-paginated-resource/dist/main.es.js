var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { watch, shallowRef, ref, computed } from "vue";
const keysOf = (object) => Object.keys(object);
const watchReactiveObjectKeys = (object, callback) => watch(keysOf(object).map((key) => () => object[key]), callback);
const createPaginatedResourceComposable = (composableOptions) => {
  var _a, _b, _c, _d, _e;
  const FRONTEND_PAGE_SIZE = composableOptions.frontend.pageSize;
  const BACKEND_PAGE_SIZE = (_a = composableOptions.backend) == null ? void 0 : _a.pageSize;
  const BACKEND_PAGE_REQUEST_KEY = ((_c = (_b = composableOptions.backend) == null ? void 0 : _b.requestKeys) == null ? void 0 : _c.page) || "page";
  const BACKEND_PAGE_SIZE_REQUEST_KEY = (_e = (_d = composableOptions.backend) == null ? void 0 : _d.requestKeys) == null ? void 0 : _e.pageSize;
  return (paginatedRequestMethod, page, resetPage, requestOptions) => {
    const elements = shallowRef([]);
    const loading = ref(false);
    const total = ref(0);
    const backendPage = ref(0);
    const firstElement = computed(() => FRONTEND_PAGE_SIZE * (page.value - 1));
    const nextElement = computed(() => FRONTEND_PAGE_SIZE * page.value);
    const remainingElements = computed(() => elements.value.length - nextElement.value);
    const previousPageAvailable = computed(() => page.value > 1);
    const nextPageAvailable = computed(() => (!loading.value || nextElement.value < elements.value.length) && nextElement.value < total.value);
    const pageLimits = computed(() => ({
      firstElement: firstElement.value,
      lastElement: Math.min(firstElement.value + FRONTEND_PAGE_SIZE - 1, total.value - 1)
    }));
    const pageElements = computed(() => elements.value.slice(firstElement.value, nextElement.value));
    const requestNextPage = async () => {
      loading.value = true;
      backendPage.value += 1;
      const pageRelatedRequestOptions = __spreadValues({
        [BACKEND_PAGE_REQUEST_KEY]: backendPage.value
      }, BACKEND_PAGE_SIZE_REQUEST_KEY !== void 0 && {
        [BACKEND_PAGE_SIZE_REQUEST_KEY]: BACKEND_PAGE_SIZE
      });
      const internalRequestOptions = __spreadValues(__spreadValues({}, pageRelatedRequestOptions), requestOptions);
      const {
        total: requestTotal,
        elements: requestElements
      } = await paginatedRequestMethod(internalRequestOptions);
      total.value = requestTotal;
      if (requestElements.length > 0) {
        elements.value = [...elements.value, ...requestElements];
      } else {
        backendPage.value -= 1;
      }
      loading.value = false;
    };
    watchReactiveObjectKeys(requestOptions, () => {
      elements.value = [];
      backendPage.value = 0;
      resetPage();
      requestNextPage();
    });
    watch(() => page.value, () => {
      if (elements.value.length > 0 && remainingElements.value < 2 * FRONTEND_PAGE_SIZE && elements.value.length < total.value) {
        requestNextPage();
      }
    });
    requestNextPage();
    return {
      total,
      pageElements,
      loading,
      previousPageAvailable,
      nextPageAvailable,
      pageLimits
    };
  };
};
export { createPaginatedResourceComposable };
//# sourceMappingURL=main.es.js.map
